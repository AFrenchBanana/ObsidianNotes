| URL                   | Username      | Password   |
| --------------------- | ------------- | ---------- |
| http://dnn/dotnetnuke | administrator | studentlab |
| rdp://dnn             | administrator | studentlab |
# Serialisation
* Converting data structures into a format that can be stored or transmitted over a data link
* This module covers XMLSerializer: https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2
## XMLSerializer Limitations

* It can only serialise *public* properties and fields of an object. 
* Supports a narrow set of objects due to the fact it cannot serialise abstract classes. 
* The type of object needs to be known to *XMLSerializer* at runtime. 
	* If it does not know this it will throw a runtime exception

### Example Serializer
* This Program will serialize the text and save it to the file
```C#
using System;
using System.IO;
using System.Xml.Serialization;  

namespace BasicXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            MyConsoleText myText = new MyConsoleText();
            myText.text = args[0];
            MySerializer(myText);
        }

        static void MySerializer(MyConsoleText txt)
        {
            var ser = new XmlSerializer(typeof(MyConsoleText));
            TextWriter writer = new StreamWriter("C:\\Users\\Public\\basicXML.txt");
            ser.Serialize(writer, txt);
            writer.Close();
        }
    }
  
    public class MyConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
        }
    }
}
```
### Example Deserializer
```C#
using System.IO;
using System.Xml.Serialization;
using BasicXMLSerializer;

namespace BasicXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
           var fileStream = new FileStream(args[0], FileMode.Open,FileAccess.Read);
            var streamReader = new StreamReader(fileStream);
            XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
            serializer.Deserialize(streamReader);
        }
    }
}
```
* Creates an instance of *XMLDeserializer* class with *MyConsoleText* as the object.
**IT NEEDS TO KNOW THE TYPE**

```C#
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace MultiXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String txt = args[0];
            int myClass = Int32.Parse(args[1]);
            if (myClass == 1)
            {
                MyFirstConsoleText myText = new MyFirstConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
            else
            {
                MySecondConsoleText myText = new MySecondConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
        }
        static void CustomSerializer(Object myObj)
        {
            XmlDocument xmlDocument = new XmlDocument();
            XmlElement xmlElement = xmlDocument.CreateElement("customRootNode");
            xmlDocument.AppendChild(xmlElement);
            XmlElement xmlElement2 = xmlDocument.CreateElement("item");
            xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
            XmlDocument xmlDocument2 = new XmlDocument();
            XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType());
            StringWriter writer = new StringWriter();
            xmlSerializer.Serialize(writer, myObj);
            xmlDocument2.LoadXml(writer.ToString());          xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true));
            xmlElement.AppendChild(xmlElement2);
            File.WriteAllText("C:\\Users\\Public\\multiXML.txt", xmlDocument.OuterXml);
        }
    }

    public class MyFirstConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
        }
    }
      public class MySecondConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My second console text class says: " + _text); }
        }
    }
}
```
* This has the ability to deserialize many objects 
* Each function has the ability to be called allowing for multiple objects
```C#
xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
```
This gets the objects name type based on the object class.  
* Deserializer: 
```C#
using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
namespace MultiXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String xml = File.ReadAllText(args[0]);
            CustomDeserializer(xml);            
        }
        static void CustomDeserializer(String myXMLString)
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(myXMLString);
            foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
            {
                string typeName = xmlItem.GetAttribute("objectType");
                var xser = new XmlSerializer(Type.GetType(typeName));
                var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                xser.Deserialize(reader);
            }
        }
    }
}
```
The de-serializer needs to be aware of both object types to properly process them.
```XML
<customRootNode>
<item objectType="MultiXMLSerializer.MyFirstConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MyFirstConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MyFirstConsoleText>
</item>
</customRootNode>
```
```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My first console text class says: Serializing first class...
```
The following 2 lines use the name of the object to call the appropriate XmlSerialiser instance. 
```C#
string typeName = xmlItem.GetAttribute("objectType");
var xser = new XmlSerializer(Type.GetType(typeName));
```
it is possible to change the contents of the serialized object file, so that rather than deserializing the _MyFirstConsoleClass_ instance, we can deserialize an instance of _MySecondConsoleClass_. In order to accomplish that, our XML file contents should look like this:
```XML
<customRootNode>
<item objectType="MultiXMLSerializer.MySecondConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MySecondConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MySecondConsoleText>
</item>
</customRootNode>
```
```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My second console text class says: Serializing first class...
```
So by changing the name of the XML we are calling a different class. 
* You need the source in order for this to occur. 
## Getting Malicious
```C#
 using System;
 using System.Diagnostics;
 using System.IO;
 using System.Xml;
 using System.Xml.Serialization;
 
 namespace MultiXMLDeserializer
 {
     class Program
     {
         static void Main(string[] args)
         {
             String xml = File.ReadAllText(args[0]);
             CustomDeserializer(xml);            
         }
 
         static void CustomDeserializer(String myXMLString)
         {
             XmlDocument xmlDocument = new XmlDocument();
             xmlDocument.LoadXml(myXMLString);
             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
             {
                 string typeName = xmlItem.GetAttribute("objectType");
                 var xser = new XmlSerializer(Type.GetType(typeName));
                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                 xser.Deserialize(reader);
             }
         }
     }
 
     public class ExecCMD
     {
         private String _cmd;
         public String cmd
         {
             get { return _cmd; }
             set
             {
                 _cmd = value;
                 ExecCommand();
             }
         }
 
         private void ExecCommand()
         {
             Process myProcess = new Process();
             myProcess.StartInfo.FileName = _cmd;
             myProcess.Start();
             myProcess.Dispose();
         }
     }
 }
```
* This serialiser implements the _ExecCMD_ 
```xml
<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>calc.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```
* Exec command just runs the command it is given
* To do this you need to change the object type to call *ExecCMD* and rename the *text* tag. 
# DotNetNukeVulnerability
* Found in the _DNNPersonalization_ cookie
## Overview
* The entry point for this vulnerability is found in the *DotnetNuke.dll*. 
	* The dll is publicly available, source for this module will be used with dnSpy
* **Need to use the 64bit of dnSpy as the dll is 64bit**
![[1bb95b5a1eda583c47acedcd2aa179bc-Picture12a.png]]![[6cd656cb021e626c072d8ab34429b3cb-Picture4.png]]
* Implementation of the *LoadProfile* function
* This function can be triggered when we visit a non existent page. 
* Line 24 the function checks the presence of the DNNPersonalisation cookie in the HTTP request. 
	* If present its value is assigned to the local text string variable on line 26.
* Following the execution path will get you to the Deserialization
![[54b9c9085d8ab9f589ac64b28630b058-Picture5 2.png]]T
* This is a wrapper for the `DeSerialiseHashTable` function.
* The second argument passed in the function call is hard coded as "profile"
![[19e8e34e2b068e6d68883a2224c064d5-Picture6 1.png]]
Implementation of the `DeserialiseHashTable`.
* look for every _item_ node under the _profile_ root XML tag (line 156)
- extract the serialized object type information from the _item_ node "type" attribute (line 160)
- create a _XmlSerializer_ instance based on the extracted object type information (line 161)
- deserialize the user-controlled serialized object (line 163)
No type checking occurs through out this. 
# Manipulation of Assembly Attributes for Debugging
* .NET can be hard to debug
* You cant add breakpoints due to runtime optimisations. 
* Sometimes cant view the local variables.
* Assembly attributes often come with this: 
```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```
This can be changed to:
```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

This can be changed in `dnSpy`
1. Open `C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll`
	1. It is important to note that once the IIS worker process starts, it will NOT load the assemblies from this directory. Rather it will make copies of all the required files for DNN to function and will load them from the following directory: `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\`
![[98dc5ab0f81f888b8ea193dcaf4bda47-Picture41 1.png]]
* Click on _Edit Assembly Attributes (C#)_
![[cf6f17b2c23dd05c2b41f638932736c6-Picture42.png]]Change to what is above
![[bd0bc1c3c5a54f0bd9cfdcde02466776-Picture43 1.png]]
_File_ > _Save Module_
![[be7c1faee9d546eadb07d27020fa4dae-Picture44 1.png]]